1.jvm结构预览
 java文件编译成class字节码文件，类加载器加载进内存                                    
2.类加载器 
 启动类加载器bootstrapclassloader 拓展类加载器extclassloader
 应用程序类加载器appclassloader    自定义加载器
 四种加载器依次层级继承
 
 双亲委派机制：一个类收到累加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给
  父类去完成，每一个层次的加载器都是如此，只有当父类反馈自己无法完成这个请求时（在他的加载）
  路径下找不到所需加载的class，子类才会尝试加载。
  好处：保证不同的类加载器最终得到一个对象，自定义的类不会污染jdk自带的。沙盒安全机制
  
3.本地方法接口&&本地方法栈 native
 作用：融合不同的语言为java所用（C/C++）,于是在内存中开辟一块空间处理标记native的代码。
 做法：在本地方法栈中登记native方法，在ExecutionEngine执行时加载native libiaries
 
4.程序计数器 pc register
 每个线程都有一个计数器，线程私有的。一个指针，指向方法中的方法字节码，用来存储下一条指令的
 内存地址，由执行引擎读取下一条指令，一个非常小的内存空间，字节码解释器通过改变这个计数器的
 值来选取下一条需要执行的字节码指令
 如果执行的是native方法，计数器为空。

5.方法区
 各线程共享的运行时内存区域，存储了每一个类的结构信息（类加载器通过class文件所创建的类的模板
 包含运行是的常量池、字段、方法数据、构造函数和普通方法中的字节码内容）
 方法区是一种规范，在不同的虚拟机里实现不一样（ps：实例变量在堆中 jdk7 字符串常量移到堆中）

6.java栈 stack 栈内存
 负责java程序的运行，线程创建时创建，生命周期跟随线程。包含8种基本变量+对象的引用变量+实例方法
 都是在栈中分配的。
 栈中的数据以栈帧存在，栈帧一块内存区 一个方法和运行期数据的数据集
 
 本地变量：输入 输出参数 方法内变量
 栈操作：记录出栈 入栈操作
 栈帧数据：包括类文件 方法操作
 
 栈运行的主要过程：当方法A被调用时 产生一个栈帧F1并压入栈中，方法A调用方法B，产生一个栈帧
 F2并压入栈中，F2执行完毕 出栈。弹出F2，在弹出F1.遵循先进后出规则。
 
 
 递归（不停的入栈）栈空间溢出
 
7.堆 heap
 一个jvm实例只存在一个堆内存，堆内存
 
 
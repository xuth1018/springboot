1.jvm结构预览
 java文件编译成class字节码文件，类加载器加载进内存                                    
2.类加载器 
 启动类加载器bootstrapclassloader 拓展类加载器extclassloader
 应用程序类加载器appclassloader    自定义加载器
 四种加载器依次层级继承
 
 双亲委派机制：一个类收到累加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给
  父类去完成，每一个层次的加载器都是如此，只有当父类反馈自己无法完成这个请求时（在他的加载）
  路径下找不到所需加载的class，子类才会尝试加载。
  好处：保证不同的类加载器最终得到一个对象，自定义的类不会污染jdk自带的。沙盒安全机制
  
3.本地方法接口&&本地方法栈 native
 作用：融合不同的语言为java所用（C/C++）,于是在内存中开辟一块空间处理标记native的代码。
 做法：在本地方法栈中登记native方法，在ExecutionEngine执行时加载native libiaries
 
4.程序计数器 pc register
 每个线程都有一个计数器，线程私有的。一个指针，指向方法中的方法字节码，用来存储下一条指令的
 内存地址，由执行引擎读取下一条指令，一个非常小的内存空间，字节码解释器通过改变这个计数器的
 值来选取下一条需要执行的字节码指令
 如果执行的是native方法，计数器为空。

5.方法区
 各线程共享的运行时内存区域，存储了每一个类的结构信息（类加载器通过class文件所创建的类的模板
 包含运行是的常量池、字段、方法数据、构造函数和普通方法中的字节码内容）
 方法区是一种规范，在不同的虚拟机里实现不一样（ps：实例变量在堆中 jdk7 字符串常量移到堆中）

6.java栈 stack 栈内存
 负责java程序的运行，线程创建时创建，生命周期跟随线程。包含8种基本变量+对象的引用变量+实例方法
 都是在栈中分配的。
 栈中的数据以栈帧存在，栈帧一块内存区 一个方法和运行期数据的数据集
 
 本地变量：输入 输出参数 方法内变量
 栈操作：记录出栈 入栈操作
 栈帧数据：包括类文件 方法操作
 
 栈运行的主要过程：当方法A被调用时 产生一个栈帧F1并压入栈中，方法A调用方法B，产生一个栈帧
 F2并压入栈中，F2执行完毕 出栈。弹出F2，在弹出F1.遵循先进后出规则。
 
 
 递归（不停的入栈）栈空间溢出
 
7.堆 heap
 一个jvm实例只存在一个堆内存，堆大小 堆中保存着所有引用类型的真实信息以方便执行器执行
 
 Eden space伊甸区              8/10
 survivor 0 space   幸存区0      1/10
 survivor 1 space 幸存区1      1/10
 old generation   老生代
 metaspace        元数据
 
 新生代：eden survivor0（from） survivor1（to） 
 老生代 old
 新：老  1:2
 java1.7 永久带  1.8 元数据
 永久带使用jvm堆内存   元数据 本机物理内存
 
 a.任何新对象都在eden区new创建 
 b.随着对象的不断创建，eden区逐渐被填满
 c.触发一次young gc（minor gc）删除为引用的对象，gc剩下来的还存在引用的对象将移动到
   幸存者区0区，然后清空eden区。对象
 d.随着对象的创建，eden区空间又满了，再一次出发gc，删除为引用的对象，这次gc留下来的对象
   移动到幸存者1区，并且上一轮gc留下来的存储在幸存者0区的对象年龄递增并移动到幸存者1区，
   当所有的对象移动到幸存者1区后，幸存者0区和eden区删除
 e.随着第三次eden区满，触发了gc，gc留下来的对象移动到幸存者0区，幸存者1区的对象年龄增长
   也移动到幸存者0区，然后伊甸园和幸存者1区的对象删除
 f.随着young gc的不断发生，幸存对象在两个幸存区不断交换存储，年龄不断递增，当幸存者年龄
   达到指定的阈值（MaxTenuringThreshold=8）他们将移动到老生代。
 g.随着上述过程的不断发生，当养老区不断变慢时，将触发major gc（full gc）进行养老区的
   内存清理。若养老区执行了gc后发现依然无法进入对象的保存 就会OOM
 
 
7：堆参数
 -Xms   堆初始大小   程序启动时
 -Xmn   堆最大内存   程序运行时
 -Xss   启动线程堆栈内存
 -Xmn   新生代内存大小
 -XX:MaxTenuring Threshold 转入养老区存活次数 阈值
 -XX:NewRatio 新生代 老生代比例  2：养老区是新生区的2倍
 -XX:NewSize  新生区初始大小
 -XX:MaxNewSize 新生最大大小
 -XX:SurvivorRatio  eden与survivor区比例 5:  5:2
 -XX:PrintGCDetails 日志打印